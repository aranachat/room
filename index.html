// ==================== Ø³ÛŒØ³ØªÙ… Ø¯ÛŒØ¨Ø§Ú¯ ====================
const DEBUG = true;
function debugLog(message, data = null) {
    if (DEBUG) {
        console.log(`ğŸ”§ ${message}`, data || '');
    }
}

// ==================== Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ø§ØµÙ„ÛŒ ====================
let peer = null;
let myVisibleName = '';
let myPeerId = '';
let currentAdminId = '';
let currentAdminName = '';
let amIAdmin = false;
let isMobile = window.innerWidth <= 768;

// Ø³ÛŒØ³ØªÙ… Ø§ØªØµØ§Ù„Ø§Øª
let directConnections = new Map(); // Ø§ØªØµØ§Ù„Ø§Øª Ù…Ø³ØªÙ‚ÛŒÙ… (Ø¨Ù‡ Ù…Ø¯ÛŒØ±)
let meshConnections = new Map(); // Ø§ØªØµØ§Ù„Ø§Øª Ù…Ø´ (Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¯ÛŒÚ¯Ø±)
let allUsers = new Map(); // ØªÙ…Ø§Ù… Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø´Ù†Ø§Ø®ØªÙ‡â€ŒØ´Ø¯Ù‡
let userColors = new Map();

// ØªØ§Ø±ÛŒØ®Ú†Ù‡
let messageHistory = [];
const MAX_MESSAGES = 500;
let messageExpirationMinutes = 5;

// Ø´Ø¨Ú©Ù‡ Ù…Ø´
let isMeshEnabled = true;
let MESH_MAX_CONNECTIONS = 4;
let meshScanInterval = null;
let meshHealthInterval = null;

// Ø«Ø§Ø¨Øªâ€ŒÙ‡Ø§
const GLOBAL_ROOM = 'CHAT_ARANA_MESH';
let wasConnectedToAdmin1 = false;

// Ø±Ù†Ú¯â€ŒÙ‡Ø§
const USER_COLORS = [
    '#8a2be2', '#00ff88', '#00ffff', '#ffaa00',
    '#ff00ff', '#00ccff', '#ffff00', '#ff4444'
];

// ==================== Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ ====================
function initSystem() {
    debugLog('Ø³ÛŒØ³ØªÙ… Ø¯Ø± Ø­Ø§Ù„ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ...');
    loadSettings();
    checkMobile();
    setupEventListeners();
}

function loadSettings() {
    const savedExpiration = localStorage.getItem('chat_expiration');
    if (savedExpiration !== null) {
        messageExpirationMinutes = parseInt(savedExpiration);
    }
    
    const savedMesh = localStorage.getItem('chat_mesh_enabled');
    if (savedMesh !== null) {
        isMeshEnabled = savedMesh === 'true';
    }
    
    debugLog('ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯:', { expiration: messageExpirationMinutes, mesh: isMeshEnabled });
}

function setupEventListeners() {
    document.getElementById('usernameInput').addEventListener('keypress', function(event) {
        if (event.key === 'Enter') login();
    });
    
    window.addEventListener('resize', checkMobile);
    
    // Ù…Ø¯ÛŒØ±ÛŒØª Ø­Ø§ÙØ¸Ù‡
    window.addEventListener('beforeunload', function(e) {
        if (directConnections.size > 0 || meshConnections.size > 0) {
            e.preventDefault();
            e.returnValue = 'Ø¢ÛŒØ§ Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø®Ø§Ø±Ø¬ Ø´ÙˆÛŒØ¯ØŸ';
        }
    });
}

// ==================== Ø³ÛŒØ³ØªÙ… ÙˆØ±ÙˆØ¯ ====================
async function login() {
    const usernameInput = document.getElementById('usernameInput');
    myVisibleName = usernameInput.value.trim();
    
    if (!myVisibleName || myVisibleName.length < 2) {
        showNotification('Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (Ø­Ø¯Ø§Ù‚Ù„ Û² Ú©Ø§Ø±Ø§Ú©ØªØ±)', 'error');
        return;
    }
    
    const loginBtn = document.getElementById('loginBtn');
    loginBtn.disabled = true;
    loginBtn.innerHTML = '<div class="loading"></div> Ø¯Ø± Ø­Ø§Ù„ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ...';
    
    try {
        // Ø§ÛŒØ¬Ø§Ø¯ Ø´Ù†Ø§Ø³Ù‡ Ù…Ù†Ø­ØµØ±Ø¨Ù‡â€ŒÙØ±Ø¯
        myPeerId = generatePeerId();
        debugLog('Ø´Ù†Ø§Ø³Ù‡ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯:', myPeerId);
        
        // Ø§ÛŒØ¬Ø§Ø¯ Peer
        peer = new Peer(myPeerId, {
            host: '0.peerjs.com',
            port: 443,
            path: '/',
            debug: 2, // Ø­Ø§Ù„Øª Ø¯ÛŒØ¨Ø§Ú¯ Ø¨Ø±Ø§ÛŒ Ù¾ÛŒÚ¯ÛŒØ±ÛŒ
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:global.stun.twilio.com:3478' }
                ]
            }
        });
        
        // Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Peer
        peer.on('open', async (id) => {
            debugLog('Peer Ø¨Ø§Ø² Ø´Ø¯:', id);
            
            // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø®ÙˆØ¯ Ø¨Ù‡ Ù„ÛŒØ³Øª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†
            allUsers.set(myPeerId, {
                peerId: myPeerId,
                visibleName: myVisibleName,
                isAdmin: false,
                isOnline: true,
                lastSeen: Date.now(),
                isMe: true,
                joinTime: Date.now()
            });
            
            showChatPage();
            
            // Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø§ØªØµØ§Ù„Ø§Øª
            setupIncomingConnections();
            
            // ØªÙ„Ø§Ø´ Ø¨Ø±Ø§ÛŒ ÛŒØ§ÙØªÙ† Ù…Ø¯ÛŒØ±
            await findAndConnectToAdmin();
            
            // Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø´Ø¨Ú©Ù‡ Ù…Ø´
            if (isMeshEnabled) {
                setupMeshNetwork();
            }
            
            showNotification('Ø´Ø¨Ú©Ù‡ ØªÙˆØ²ÛŒØ¹â€ŒØ´Ø¯Ù‡ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø´Ø¯!', 'success');
            updateUI();
        });
        
        peer.on('error', (err) => {
            console.error('Ø®Ø·Ø§ÛŒ Peer:', err);
            showNotification(`Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„: ${err.type}`, 'error');
            loginBtn.disabled = false;
            loginBtn.innerHTML = '<span>ğŸš€ ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ú†Øª</span>';
        });
        
    } catch (error) {
        console.error('Ø®Ø·Ø§ Ø¯Ø± ÙˆØ±ÙˆØ¯:', error);
        showNotification('Ø®Ø·Ø§ Ø¯Ø± Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø³ÛŒØ³ØªÙ…', 'error');
        loginBtn.disabled = false;
        loginBtn.innerHTML = '<span>ğŸš€ ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ú†Øª</span>';
    }
}

// ==================== Ø³ÛŒØ³ØªÙ… Ù…Ø¯ÛŒØ±ÛŒØª ====================
async function findAndConnectToAdmin() {
    debugLog('Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ø¯ÛŒØ±...');
    showNotification('ğŸ” Ø¯Ø± Ø­Ø§Ù„ Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ø¯ÛŒØ±...', 'info');
    
    // Ø§ÙˆÙ„ admin1 Ø±Ø§ Ú†Ú© Ú©Ù†
    const admin1Id = `${GLOBAL_ROOM}_admin1`;
    const admin2Id = `${GLOBAL_ROOM}_admin2`;
    
    const admin1Exists = await testConnection(admin1Id);
    
    if (admin1Exists) {
        debugLog('admin1 Ù¾ÛŒØ¯Ø§ Ø´Ø¯');
        currentAdminName = 'admin1';
        currentAdminId = admin1Id;
        wasConnectedToAdmin1 = true;
        await connectToAdmin();
        return true;
    }
    
    // Ø³Ù¾Ø³ admin2 Ø±Ø§ Ú†Ú© Ú©Ù†
    const admin2Exists = await testConnection(admin2Id);
    
    if (admin2Exists) {
        debugLog('admin2 Ù¾ÛŒØ¯Ø§ Ø´Ø¯');
        currentAdminName = 'admin2';
        currentAdminId = admin2Id;
        await connectToAdmin();
        return true;
    }
    
    debugLog('Ù‡ÛŒÚ† Ù…Ø¯Ø±ÛŒ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯');
    showNotification('âš ï¸ Ù…Ø¯ÛŒØ± Ø¢Ù†Ù„Ø§ÛŒÙ† ÛŒØ§ÙØª Ù†Ø´Ø¯', 'warning');
    
    // Ø§Ú¯Ø± Ø´Ø¨Ú©Ù‡ Ù…Ø´ ÙØ¹Ø§Ù„ Ø§Ø³ØªØŒ Ø¬Ø³ØªØ¬Ùˆ Ø¯Ø± Ø´Ø¨Ú©Ù‡
    if (isMeshEnabled) {
        searchForAdminInMesh();
    }
    
    return false;
}

async function testConnection(peerId) {
    return new Promise((resolve) => {
        const testPeer = new Peer(`test_${Date.now()}`, {
            host: '0.peerjs.com',
            port: 443,
            path: '/'
        });
        
        const timeout = setTimeout(() => {
            testPeer.destroy();
            resolve(false);
        }, 3000);
        
        testPeer.on('open', () => {
            const conn = testPeer.connect(peerId, {
                reliable: true,
                metadata: { type: 'connection_test' }
            });
            
            conn.on('open', () => {
                clearTimeout(timeout);
                conn.close();
                testPeer.destroy();
                resolve(true);
            });
            
            conn.on('error', () => {
                clearTimeout(timeout);
                testPeer.destroy();
                resolve(false);
            });
        });
        
        testPeer.on('error', () => {
            clearTimeout(timeout);
            resolve(false);
        });
    });
}

async function connectToAdmin() {
    debugLog(`Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ù…Ø¯ÛŒØ±: ${currentAdminName}`);
    
    const conn = peer.connect(currentAdminId, {
        reliable: true,
        metadata: {
            type: 'member_connection',
            visibleName: myVisibleName,
            peerId: myPeerId,
            timestamp: Date.now()
        }
    });
    
    conn.on('open', () => {
        debugLog(`âœ… Ø¨Ù‡ ${currentAdminName} Ù…ØªØµÙ„ Ø´Ø¯ÛŒÙ…`);
        directConnections.set(currentAdminId, conn);
        setupConnectionListeners(conn, currentAdminId);
        
        // Ø«Ø¨Øªâ€ŒÙ†Ø§Ù…
        conn.send({
            type: 'register',
            peerId: myPeerId,
            visibleName: myVisibleName,
            timestamp: Date.now(),
            joinTime: Date.now()
        });
        
        showNotification(`Ø¨Ù‡ ${currentAdminName} Ù…ØªØµÙ„ Ø´Ø¯ÛŒØ¯`, 'success');
        updateConnectionStatus();
    });
    
    conn.on('error', (err) => {
        debugLog(`âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ù…Ø¯ÛŒØ±:`, err);
        directConnections.delete(currentAdminId);
        updateConnectionStatus();
        
        // Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ø¯ÛŒØ± Ø¬Ø¯ÛŒØ¯
        setTimeout(() => findAndConnectToAdmin(), 3000);
    });
}

// ==================== Ø´Ø¨Ú©Ù‡ Ù…Ø´ ====================
function setupMeshNetwork() {
    debugLog('Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø´Ø¨Ú©Ù‡ Ù…Ø´...');
    
    // Ø´Ø±ÙˆØ¹ Ø§Ø³Ú©Ù† Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±Ø§Ù†
    startMeshScanning();
    
    // Ø´Ø±ÙˆØ¹ Ù†Ø¸Ø§Ø±Øª Ø¨Ø± Ø³Ù„Ø§Ù…Øª Ø´Ø¨Ú©Ù‡
    startMeshHealthCheck();
    
    // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª
    updateMeshStatus();
    
    showNotification('ğŸŒ Ø´Ø¨Ú©Ù‡ Ù…Ø´ ÙØ¹Ø§Ù„ Ø´Ø¯', 'info');
}

function startMeshScanning() {
    if (meshScanInterval) clearInterval(meshScanInterval);
    
    meshScanInterval = setInterval(() => {
        // Ø§Ú¯Ø± Ø§ØªØµØ§Ù„Ø§Øª Ú©Ù… Ø¯Ø§Ø±ÛŒÙ…ØŒ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¬Ø¯ÛŒØ¯ Ø¬Ø³ØªØ¬Ùˆ Ú©Ù†
        if (meshConnections.size < MESH_MAX_CONNECTIONS) {
            discoverNewPeers();
        }
        
        // Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ø§ØªØµØ§Ù„Ø§Øª Ù…Ø±Ø¯Ù‡
        cleanupDeadConnections();
        
        // Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ UI
        updateMeshStatus();
    }, 10000); // Ù‡Ø± 10 Ø«Ø§Ù†ÛŒÙ‡
}

function discoverNewPeers() {
    debugLog('Ø¬Ø³ØªØ¬ÙˆÛŒ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¬Ø¯ÛŒØ¯...');
    
    // Ø§Ú¯Ø± Ù…Ø¯ÛŒØ± Ø¯Ø§Ø±ÛŒÙ…ØŒ Ø§Ø² Ø§Ùˆ Ù„ÛŒØ³Øª Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø±Ø§ Ø¨Ú¯ÛŒØ±
    if (currentAdminId && directConnections.has(currentAdminId)) {
        const adminConn = directConnections.get(currentAdminId);
        if (adminConn.open) {
            adminConn.send({
                type: 'get_users',
                timestamp: Date.now()
            });
        }
    }
    
    // Ø¯Ø± Ø´Ø¨Ú©Ù‡ Ù…Ø´ Ø¬Ø³ØªØ¬Ùˆ Ú©Ù†
    broadcastToMesh({
        type: 'peer_discovery',
        peerId: myPeerId,
        visibleName: myVisibleName,
        timestamp: Date.now()
    });
    
    // Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø´Ù†Ø§Ø®ØªÙ‡â€ŒØ´Ø¯Ù‡ Ù…ØªØµÙ„ Ø´Ùˆ
    connectToKnownPeers();
}

function connectToKnownPeers() {
    const onlineUsers = Array.from(allUsers.values())
        .filter(user => 
            user.isOnline && 
            user.peerId !== myPeerId && 
            !meshConnections.has(user.peerId) &&
            !directConnections.has(user.peerId)
        );
    
    if (onlineUsers.length === 0) {
        debugLog('Ù‡ÛŒÚ† Ú©Ø§Ø±Ø¨Ø± Ø¢Ù†Ù„Ø§ÛŒÙ†ÛŒ Ø¨Ø±Ø§ÛŒ Ø§ØªØµØ§Ù„ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯');
        return;
    }
    
    // Ø§Ù†ØªØ®Ø§Ø¨ ØªØµØ§Ø¯ÙÛŒ Ø­Ø¯Ø§Ú©Ø«Ø± 2 Ú©Ø§Ø±Ø¨Ø±
    const shuffled = [...onlineUsers].sort(() => Math.random() - 0.5);
    const toConnect = shuffled.slice(0, Math.min(2, MESH_MAX_CONNECTIONS - meshConnections.size));
    
    toConnect.forEach(user => {
        if (meshConnections.size < MESH_MAX_CONNECTIONS) {
            connectToMeshPeer(user.peerId);
        }
    });
}

function connectToMeshPeer(peerId) {
    if (meshConnections.has(peerId) || peerId === myPeerId) {
        return;
    }
    
    debugLog(`ØªÙ„Ø§Ø´ Ø¨Ø±Ø§ÛŒ Ø§ØªØµØ§Ù„ Ù…Ø´ Ø¨Ù‡ ${peerId}`);
    
    const conn = peer.connect(peerId, {
        reliable: true,
        metadata: {
            type: 'mesh_connection',
            visibleName: myVisibleName,
            peerId: myPeerId,
            timestamp: Date.now()
        }
    });
    
    conn.on('open', () => {
        debugLog(`âœ… Ø§ØªØµØ§Ù„ Ù…Ø´ Ø¨Ù‡ ${peerId} Ø¨Ø±Ù‚Ø±Ø§Ø± Ø´Ø¯`);
        meshConnections.set(peerId, conn);
        setupMeshConnectionListeners(conn, peerId);
        
        // ØªØ¨Ø§Ø¯Ù„ Ø§Ø·Ù„Ø§Ø¹Ø§Øª
        conn.send({
            type: 'mesh_handshake',
            peerId: myPeerId,
            visibleName: myVisibleName,
            timestamp: Date.now(),
            knownUsers: Array.from(allUsers.keys())
        });
        
        updateMeshStatus();
    });
    
    conn.on('error', (err) => {
        debugLog(`âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ Ù…Ø´ Ø¨Ù‡ ${peerId}:`, err);
        meshConnections.delete(peerId);
        updateMeshStatus();
    });
}

function setupMeshConnectionListeners(conn, peerId) {
    conn.on('data', (data) => {
        handleMeshData(data, peerId);
    });
    
    conn.on('close', () => {
        debugLog(`Ø§ØªØµØ§Ù„ Ù…Ø´ Ø¨Ø§ ${peerId} Ø¨Ø³ØªÙ‡ Ø´Ø¯`);
        meshConnections.delete(peerId);
        updateMeshStatus();
    });
    
    conn.on('error', (err) => {
        debugLog(`Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ Ù…Ø´ ${peerId}:`, err);
        meshConnections.delete(peerId);
        updateMeshStatus();
    });
}

function cleanupDeadConnections() {
    meshConnections.forEach((conn, peerId) => {
        if (!conn.open) {
            meshConnections.delete(peerId);
        }
    });
}

function broadcastToMesh(data, excludePeers = []) {
    let sentCount = 0;
    
    meshConnections.forEach((conn, peerId) => {
        if (conn.open && !excludePeers.includes(peerId)) {
            try {
                conn.send(data);
                sentCount++;
            } catch (error) {
                debugLog(`Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ ${peerId}:`, error);
                meshConnections.delete(peerId);
            }
        }
    });
    
    debugLog(`Ù¾ÛŒØ§Ù… Ø¨Ù‡ ${sentCount} Ú©Ø§Ø±Ø¨Ø± Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯`);
    return sentCount > 0;
}

// ==================== Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ ====================
function setupIncomingConnections() {
    peer.on('connection', (conn) => {
        debugLog('Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø§ØªØµØ§Ù„ Ø¯Ø±ÛŒØ§ÙØªÛŒ Ø§Ø²:', conn.peer);
        
        const metadata = conn.metadata || {};
        const peerId = conn.peer;
        
        if (metadata.type === 'mesh_connection') {
            // Ø§ØªØµØ§Ù„ Ù…Ø´
            meshConnections.set(peerId, conn);
            setupMeshConnectionListeners(conn, peerId);
            
            // Ø§Ø±Ø³Ø§Ù„ Ù¾Ø§Ø³Ø®
            conn.send({
                type: 'mesh_welcome',
                peerId: myPeerId,
                visibleName: myVisibleName,
                timestamp: Date.now()
            });
        } else {
            // Ø§ØªØµØ§Ù„ Ù…Ø³ØªÙ‚ÛŒÙ…
            directConnections.set(peerId, conn);
            setupConnectionListeners(conn, peerId);
        }
    });
}

function setupConnectionListeners(conn, peerId) {
    conn.on('open', () => {
        debugLog(`Ø§ØªØµØ§Ù„ Ø¨Ø§ ${peerId} Ø¨Ø§Ø² Ø´Ø¯`);
    });
    
    conn.on('data', (data) => {
        handleIncomingData(data, peerId);
    });
    
    conn.on('close', () => {
        debugLog(`Ø§ØªØµØ§Ù„ Ø¨Ø§ ${peerId} Ø¨Ø³ØªÙ‡ Ø´Ø¯`);
        directConnections.delete(peerId);
        
        if (peerId === currentAdminId) {
            showNotification('Ø§ØªØµØ§Ù„ Ø¨Ø§ Ù…Ø¯ÛŒØ± Ù‚Ø·Ø¹ Ø´Ø¯', 'warning');
            findAndConnectToAdmin();
        }
    });
    
    conn.on('error', (err) => {
        debugLog(`Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ ${peerId}:`, err);
        directConnections.delete(peerId);
    });
}

function handleIncomingData(data, fromPeerId) {
    debugLog('Ø¯Ø§Ø¯Ù‡ Ø¯Ø±ÛŒØ§ÙØªÛŒ:', { type: data.type, from: fromPeerId });
    
    switch(data.type) {
        case 'register':
            handleUserRegistration(data, fromPeerId);
            break;
        case 'user_list':
            handleUserList(data, fromPeerId);
            break;
        case 'public_message':
            handlePublicMessage(data, fromPeerId);
            break;
        case 'system_message':
            handleSystemMessage(data, fromPeerId);
            break;
        case 'get_users':
            handleGetUsers(data, fromPeerId);
            break;
        case 'admin_info':
            handleAdminInfo(data, fromPeerId);
            break;
    }
}

function handleMeshData(data, fromPeerId) {
    debugLog('Ø¯Ø§Ø¯Ù‡ Ù…Ø´ Ø¯Ø±ÛŒØ§ÙØªÛŒ:', { type: data.type, from: fromPeerId });
    
    switch(data.type) {
        case 'mesh_handshake':
            handleMeshHandshake(data, fromPeerId);
            break;
        case 'mesh_welcome':
            handleMeshWelcome(data, fromPeerId);
            break;
        case 'peer_discovery':
            handlePeerDiscovery(data, fromPeerId);
            break;
        case 'mesh_message':
            handleMeshMessage(data, fromPeerId);
            break;
        case 'admin_search':
            handleAdminSearch(data, fromPeerId);
            break;
        case 'admin_found':
            handleAdminFound(data, fromPeerId);
            break;
    }
}

// ==================== Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ ====================
function handleUserRegistration(data, fromPeerId) {
    const userInfo = {
        peerId: data.peerId,
        visibleName: data.visibleName,
        isAdmin: false,
        isOnline: true,
        lastSeen: Date.now(),
        joinTime: data.joinTime || Date.now(),
        isMe: data.peerId === myPeerId
    };
    
    allUsers.set(data.peerId, userInfo);
    
    // Ø§Ø±Ø³Ø§Ù„ Ù¾Ø§Ø³Ø®
    const conn = directConnections.get(fromPeerId);
    if (conn && conn.open) {
        conn.send({
            type: 'user_list',
            users: Array.from(allUsers.values()).filter(u => u.isOnline),
            timestamp: Date.now()
        });
    }
    
    // Ø§Ø·Ù„Ø§Ø¹ Ø¨Ù‡ Ø´Ø¨Ú©Ù‡ Ù…Ø´
    broadcastToMesh({
        type: 'user_discovery',
        user: userInfo,
        timestamp: Date.now()
    });
    
    showNotification(`Ú©Ø§Ø±Ø¨Ø± Ø¬Ø¯ÛŒØ¯: ${data.visibleName}`, 'info');
    updateUsersList();
}

function handleUserList(data, fromPeerId) {
    data.users.forEach(user => {
        if (!allUsers.has(user.peerId)) {
            allUsers.set(user.peerId, user);
        }
    });
    
    updateUsersList();
}

function handlePublicMessage(data, fromPeerId) {
    // Ù†Ù…Ø§ÛŒØ´ Ù¾ÛŒØ§Ù…
    displayMessage(data, data.senderId === myPeerId);
    
    // Ø§Ú¯Ø± Ù…Ø¯ÛŒØ± Ù‡Ø³ØªÙ…ØŒ Ø¨Ù‡ Ø¯ÛŒÚ¯Ø±Ø§Ù† ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ú©Ù†
    if (amIAdmin) {
        broadcastToAll(data, [fromPeerId, myPeerId]);
        broadcastToMesh(data, [fromPeerId, myPeerId]);
    }
}

function handleMeshHandshake(data, fromPeerId) {
    // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ú©Ø§Ø±Ø¨Ø±
    if (!allUsers.has(data.peerId)) {
        allUsers.set(data.peerId, {
            peerId: data.peerId,
            visibleName: data.visibleName,
            isAdmin: false,
            isOnline: true,
            lastSeen: Date.now(),
            joinTime: Date.now(),
            isMe: false
        });
    }
    
    // Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø´Ù†Ø§Ø®ØªÙ‡â€ŒØ´Ø¯Ù‡
    data.knownUsers?.forEach(peerId => {
        if (peerId !== myPeerId && 
            !meshConnections.has(peerId) && 
            !directConnections.has(peerId) &&
            meshConnections.size < MESH_MAX_CONNECTIONS) {
            
            setTimeout(() => connectToMeshPeer(peerId), Math.random() * 2000);
        }
    });
    
    updateUsersList();
}

function handleMeshWelcome(data, fromPeerId) {
    debugLog('Ø®ÙˆØ´ Ø¢Ù…Ø¯Ú¯ÙˆÛŒÛŒ Ø§Ø²:', data.visibleName);
    
    if (!allUsers.has(data.peerId)) {
        allUsers.set(data.peerId, {
            peerId: data.peerId,
            visibleName: data.visibleName,
            isAdmin: false,
            isOnline: true,
            lastSeen: Date.now(),
            joinTime: Date.now(),
            isMe: false
        });
    }
    
    updateUsersList();
}

function handlePeerDiscovery(data, fromPeerId) {
    // Ù¾Ø§Ø³Ø® Ø¨Ø§ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø®ÙˆØ¯
    const conn = meshConnections.get(fromPeerId);
    if (conn && conn.open) {
        conn.send({
            type: 'mesh_welcome',
            peerId: myPeerId,
            visibleName: myVisibleName,
            timestamp: Date.now()
        });
    }
    
    // Ø§Ú¯Ø± Ú©Ø§Ø±Ø¨Ø± Ø±Ø§ Ù†Ù…ÛŒâ€ŒØ´Ù†Ø§Ø³Ù…ØŒ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†
    if (!allUsers.has(data.peerId)) {
        allUsers.set(data.peerId, {
            peerId: data.peerId,
            visibleName: data.visibleName,
            isAdmin: false,
            isOnline: true,
            lastSeen: Date.now(),
            joinTime: Date.now(),
            isMe: false
        });
        
        updateUsersList();
    }
}

// ==================== Ø³ÛŒØ³ØªÙ… Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ø¯ÛŒØ± Ø¯Ø± Ø´Ø¨Ú©Ù‡ Ù…Ø´ ====================
function searchForAdminInMesh() {
    debugLog('Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ø¯ÛŒØ± Ø¯Ø± Ø´Ø¨Ú©Ù‡ Ù…Ø´...');
    
    broadcastToMesh({
        type: 'admin_search',
        searcherId: myPeerId,
        timestamp: Date.now()
    });
    
    // Ø§Ú¯Ø± Ø¨Ø¹Ø¯ Ø§Ø² 10 Ø«Ø§Ù†ÛŒÙ‡ Ù…Ø¯ÛŒØ± Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯ØŒ Ø§Ù†ØªØ®Ø§Ø¨Ø§Øª Ø´Ø±ÙˆØ¹ Ú©Ù†
    setTimeout(() => {
        if (!currentAdminId && !amIAdmin) {
            startElection();
        }
    }, 10000);
}

function handleAdminSearch(data, fromPeerId) {
    // Ø§Ú¯Ø± Ù…Ù† Ù…Ø¯ÛŒØ± Ù‡Ø³ØªÙ… ÛŒØ§ Ù…Ø¯ÛŒØ± Ø±Ø§ Ù…ÛŒâ€ŒØ´Ù†Ø§Ø³Ù…
    if (amIAdmin) {
        const conn = meshConnections.get(fromPeerId);
        if (conn && conn.open) {
            conn.send({
                type: 'admin_found',
                adminId: myPeerId,
                adminName: myVisibleName,
                timestamp: Date.now()
            });
        }
    } else if (currentAdminId) {
        const conn = meshConnections.get(fromPeerId);
        if (conn && conn.open) {
            conn.send({
                type: 'admin_found',
                adminId: currentAdminId,
                adminName: allUsers.get(currentAdminId)?.visibleName || 'Ù…Ø¯ÛŒØ±',
                timestamp: Date.now()
            });
        }
    } else {
        // Ù…Ø¯ÛŒØ± Ù†Ù…ÛŒâ€ŒØ´Ù†Ø§Ø³Ù…ØŒ ÙÙˆØ±ÙˆØ§Ø±Ø¯ Ú©Ù†
        broadcastToMesh(data, [fromPeerId]);
    }
}

function handleAdminFound(data, fromPeerId) {
    if (!currentAdminId) {
        currentAdminId = data.adminId;
        currentAdminName = data.adminName;
        
        showNotification(`âœ… Ù…Ø¯ÛŒØ± Ù¾ÛŒØ¯Ø§ Ø´Ø¯: ${data.adminName}`, 'success');
        
        // Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ù…Ø¯ÛŒØ±
        if (!meshConnections.has(data.adminId) && !directConnections.has(data.adminId)) {
            connectToAdmin();
        }
        
        updateAdminStatus();
    }
}

// ==================== Ø³ÛŒØ³ØªÙ… Ø§Ù†ØªØ®Ø§Ø¨Ø§Øª ====================
function startElection() {
    debugLog('Ø´Ø±ÙˆØ¹ Ø§Ù†ØªØ®Ø§Ø¨Ø§Øª...');
    showNotification('ğŸ‘‘ Ø´Ø±ÙˆØ¹ Ø§Ù†ØªØ®Ø§Ø¨Ø§Øª Ù…Ø¯ÛŒØ± Ø¬Ø¯ÛŒØ¯...', 'info');
    
    // ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ Ù…Ø¯ÛŒØ± Ø§Ø¶Ø·Ø±Ø§Ø±ÛŒ
    becomeEmergencyAdmin();
}

function becomeEmergencyAdmin() {
    if (amIAdmin) return;
    
    debugLog('ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ Ù…Ø¯ÛŒØ± Ø§Ø¶Ø·Ø±Ø§Ø±ÛŒ...');
    
    amIAdmin = true;
    currentAdminName = 'emergency_admin';
    currentAdminId = myPeerId;
    
    // Ø§Ø·Ù„Ø§Ø¹ Ø¨Ù‡ Ø´Ø¨Ú©Ù‡
    broadcastToMesh({
        type: 'new_admin',
        adminId: myPeerId,
        adminName: myVisibleName,
        timestamp: Date.now()
    });
    
    showNotification('ğŸ‘‘ Ø´Ù…Ø§ Ù…Ø¯ÛŒØ± Ø§Ø¶Ø·Ø±Ø§Ø±ÛŒ Ø´Ø¯ÛŒØ¯!', 'success');
    updateAdminStatus();
    
    // Ù¾ÛŒØ§Ù… Ø³ÛŒØ³ØªÙ…
    const systemMsg = {
        type: 'system_message',
        content: `ğŸ‘‘ ${myVisibleName} Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† Ù…Ø¯ÛŒØ± Ø§Ø¶Ø·Ø±Ø§Ø±ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯`,
        timestamp: Date.now(),
        messageId: generateMessageId(),
        isSystem: true
    };
    
    displayMessage(systemMsg, false);
    addToHistory(systemMsg);
}

// ==================== UI Functions ====================
function showChatPage() {
    document.getElementById('loginPage').style.display = 'none';
    document.getElementById('chatContainer').style.display = 'flex';
    updateUI();
}

function updateUI() {
    updateUsersList();
    updateConnectionStatus();
    updateMeshStatus();
    updateAdminStatus();
}

function updateUsersList() {
    const container = document.getElementById('publicUsersList');
    if (!container) return;
    
    container.innerHTML = '';
    
    // ØªØ¹Ø¯Ø§Ø¯ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¢Ù†Ù„Ø§ÛŒÙ†
    const onlineCount = Array.from(allUsers.values()).filter(u => u.isOnline).length;
    document.getElementById('onlineCount').textContent = `${onlineCount} Ú©Ø§Ø±Ø¨Ø±`;
    
    // Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø±Ø¨Ø±Ø§Ù†
    allUsers.forEach((user, peerId) => {
        const userEl = createUserElement(user);
        container.appendChild(userEl);
    });
    
    if (allUsers.size === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">Ù‡ÛŒÚ† Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯</div>';
    }
}

function createUserElement(user) {
    const el = document.createElement('div');
    el.className = 'user-item';
    
    const isConnected = meshConnections.has(user.peerId) || directConnections.has(user.peerId);
    const isMe = user.peerId === myPeerId;
    const color = getUserColor(user.peerId);
    
    el.innerHTML = `
        <div style="width: 40px; height: 40px; border-radius: 50%; background: ${color}; 
                    display: flex; align-items: center; justify-content: center; font-weight: bold; color: white;">
            ${user.visibleName.charAt(0)}
        </div>
        <div style="flex: 1;">
            <div style="display: flex; align-items: center; gap: 8px;">
                <div style="width: 8px; height: 8px; border-radius: 50%; 
                            background: ${user.isOnline ? '#00ff88' : '#ff4444'};"></div>
                <span style="font-weight: 500;">${user.visibleName}</span>
                ${isMe ? '<span style="background: #8a2be2; color: white; padding: 2px 8px; border-radius: 10px; font-size: 11px;">Ø´Ù…Ø§</span>' : ''}
                ${user.isAdmin ? '<span style="background: #ffaa00; color: black; padding: 2px 8px; border-radius: 10px; font-size: 11px;">Ù…Ø¯ÛŒØ±</span>' : ''}
            </div>
            <div style="font-size: 12px; color: #aaa; margin-top: 4px;">
                ${isConnected ? 'âœ… Ù…ØªØµÙ„' : 'ğŸ”— Ø¯Ø± Ø¯Ø³ØªØ±Ø³'}
            </div>
        </div>
    `;
    
    return el;
}

function updateConnectionStatus() {
    const indicator = document.getElementById('statusIndicator');
    const statusText = document.getElementById('connectionStatus');
    
    if (!indicator || !statusText) return;
    
    const totalConnections = directConnections.size + meshConnections.size;
    
    if (totalConnections > 0) {
        indicator.className = 'status-indicator status-online';
        statusText.textContent = `ğŸŸ¢ Ù…ØªØµÙ„ (${totalConnections} Ø§ØªØµØ§Ù„)`;
    } else {
        indicator.className = 'status-indicator status-offline';
        statusText.textContent = 'ğŸ”´ Ù‚Ø·Ø¹';
    }
}

function updateMeshStatus() {
    const meshCount = document.getElementById('meshCount');
    const meshStatusText = document.getElementById('meshStatusText');
    
    if (!meshCount || !meshStatusText) return;
    
    const count = meshConnections.size;
    meshCount.textContent = count;
    
    if (isMeshEnabled) {
        if (count >= 3) {
            meshStatusText.textContent = 'ğŸŒ Ù‚ÙˆÛŒ';
        } else if (count >= 1) {
            meshStatusText.textContent = 'ğŸ”µ Ù…ØªÙˆØ³Ø·';
        } else {
            meshStatusText.textContent = 'ğŸŸ¡ Ø¶Ø¹ÛŒÙ';
        }
    } else {
        meshStatusText.textContent = 'ØºÛŒØ±ÙØ¹Ø§Ù„';
    }
}

function updateAdminStatus() {
    const adminStatus = document.getElementById('adminStatusDisplay');
    if (!adminStatus) return;
    
    if (amIAdmin) {
        adminStatus.innerHTML = '<span style="color: #00ff88;">ğŸ‘‘ Ø´Ù…Ø§ Ù…Ø¯ÛŒØ± Ù‡Ø³ØªÛŒØ¯</span>';
    } else if (currentAdminId) {
        adminStatus.innerHTML = `<span style="color: #8a2be2;">Ù…Ø¯ÛŒØ±: ${currentAdminName}</span>`;
    } else {
        adminStatus.innerHTML = '<span style="color: #ffaa00;">ğŸ” Ø¯Ø± Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ø¯ÛŒØ±...</span>';
    }
}

// ==================== Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… ====================
function sendMessage() {
    const input = document.getElementById('messageInput');
    const content = input.value.trim();
    
    if (!content) return;
    
    const messageData = {
        type: 'public_message',
        content: content,
        senderId: myPeerId,
        senderName: myVisibleName,
        timestamp: Date.now(),
        messageId: generateMessageId(),
        status: 'sending',
        likes: [],
        dislikes: []
    };
    
    displayMessage(messageData, true);
    
    // Ø§Ú¯Ø± Ù…Ø¯ÛŒØ± Ù‡Ø³ØªÙ…
    if (amIAdmin) {
        addToHistory(messageData);
        broadcastToAll(messageData, [myPeerId]);
        broadcastToMesh(messageData, [myPeerId]);
        updateMessageStatus(messageData.messageId, 'delivered');
    } 
    // Ø§Ú¯Ø± Ø¨Ù‡ Ù…Ø¯ÛŒØ± ÙˆØµÙ„ Ù‡Ø³ØªÙ…
    else if (currentAdminId && directConnections.has(currentAdminId)) {
        const adminConn = directConnections.get(currentAdminId);
        if (adminConn.open) {
            adminConn.send(messageData);
        } else {
            sendViaMesh(messageData);
        }
    }
    // Ø¯Ø± ØºÛŒØ± Ø§ÛŒÙ† ØµÙˆØ±Øª Ø§Ø² Ø·Ø±ÛŒÙ‚ Ù…Ø´ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†
    else {
        sendViaMesh(messageData);
    }
    
    input.value = '';
    autoResize(input);
}

function sendViaMesh(messageData) {
    if (!isMeshEnabled || meshConnections.size === 0) {
        showNotification('âš ï¸ Ø´Ø¨Ú©Ù‡ Ù…Ø´ ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª ÛŒØ§ Ù‡ÛŒÚ† Ø§ØªØµØ§Ù„ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯', 'warning');
        updateMessageStatus(messageData.messageId, 'failed');
        return;
    }
    
    // Ø¹Ù„Ø§Ù…Øªâ€ŒÚ¯Ø°Ø§Ø±ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø¯Ø± Ø´Ø¨Ú©Ù‡ Ù…Ø´
    messageData.viaMesh = true;
    
    const sent = broadcastToMesh(messageData);
    if (sent) {
        updateMessageStatus(messageData.messageId, 'delivered');
    } else {
        updateMessageStatus(messageData.messageId, 'failed');
    }
}

function broadcastToAll(data, excludePeers = []) {
    directConnections.forEach((conn, peerId) => {
        if (conn.open && !excludePeers.includes(peerId)) {
            try {
                conn.send(data);
            } catch (error) {
                console.error('Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„:', error);
            }
        }
    });
}

// ==================== ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ ====================
function generatePeerId() {
    const randomStr = Math.random().toString(36).substring(2, 10);
    return `${GLOBAL_ROOM}_${Date.now()}_${randomStr}`;
}

function generateMessageId() {
    return `${myPeerId}_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
}

function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    
    let icon = 'ğŸ’¡';
    if (type === 'success') icon = 'âœ…';
    if (type === 'error') icon = 'âŒ';
    if (type === 'warning') icon = 'âš ï¸';
    
    notification.innerHTML = `
        <span class="notification-icon">${icon}</span>
        <span>${message}</span>
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => notification.remove(), 300);
    }, 4000);
}

function getUserColor(peerId) {
    if (!userColors.has(peerId)) {
        const hash = peerId.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
        const colorIndex = hash % USER_COLORS.length;
        userColors.set(peerId, USER_COLORS[colorIndex]);
    }
    return userColors.get(peerId);
}

function addToHistory(message) {
    messageHistory.push(message);
    if (messageHistory.length > MAX_MESSAGES) {
        messageHistory.shift();
    }
    if (amIAdmin) {
        localStorage.setItem('chat_message_history', JSON.stringify(messageHistory));
    }
}

function displayMessage(data, isOutgoing) {
    const container = document.getElementById('messagesContainer');
    const emptyState = document.getElementById('emptyState');
    
    if (emptyState) emptyState.style.display = 'none';
    
    const messageEl = document.createElement('div');
    messageEl.className = `message ${isOutgoing ? 'outgoing' : 'incoming'}`;
    
    const time = new Date(data.timestamp).toLocaleTimeString('fa-IR', {
        hour: '2-digit',
        minute: '2-digit'
    });
    
    messageEl.innerHTML = `
        <div class="message-header">
            <span class="message-sender">${data.senderName}</span>
            <span class="message-time">${time}</span>
        </div>
        <div class="message-content">${data.content}</div>
    `;
    
    container.appendChild(messageEl);
    container.scrollTop = container.scrollHeight;
}

function updateMessageStatus(messageId, status) {
    const messageEl = document.getElementById(`msg_${messageId}`);
    if (messageEl) {
        const statusEl = messageEl.querySelector('.message-status');
        if (statusEl) {
            statusEl.textContent = status === 'delivered' ? 'âœ“âœ“' : status === 'failed' ? 'âœ—' : 'ğŸ•';
        }
    }
}

function autoResize(textarea) {
    textarea.style.height = 'auto';
    textarea.style.height = Math.min(textarea.scrollHeight, 150) + 'px';
}

function handleKeyPress(event) {
    if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
    }
}

function toggleSidebar() {
    const sidebar = document.getElementById('sidebar');
    const overlay = document.getElementById('mobileOverlay');
    
    if (sidebar.classList.contains('active')) {
        sidebar.classList.remove('active');
        overlay.classList.remove('active');
    } else {
        sidebar.classList.add('active');
        overlay.classList.add('active');
    }
}

function checkMobile() {
    isMobile = window.innerWidth <= 768;
    if (isMobile) {
        document.body.style.padding = '0';
    } else {
        document.body.style.padding = '20px';
    }
}

function refreshConnections() {
    showNotification('ğŸ”„ Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§ØªØµØ§Ù„Ø§Øª...', 'info');
    discoverNewPeers();
    updateUI();
}

function clearLocalStorage() {
    if (confirm('Ø¢ÛŒØ§ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù¾Ø§Ú© Ø´ÙˆØ¯ØŸ')) {
        localStorage.clear();
        showNotification('Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù¾Ø§Ú© Ø´Ø¯', 'success');
    }
}

function leaveChat() {
    if (confirm('Ø¢ÛŒØ§ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø§Ø² Ú†Øª Ø®Ø§Ø±Ø¬ Ø´ÙˆÛŒØ¯ØŸ')) {
        // Ø¨Ø³ØªÙ† Ø§ØªØµØ§Ù„Ø§Øª
        directConnections.forEach(conn => conn.close());
        meshConnections.forEach(conn => conn.close());
        
        // Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ ØµÙØ­Ù‡ ÙˆØ±ÙˆØ¯
        document.getElementById('loginPage').style.display = 'flex';
        document.getElementById('chatContainer').style.display = 'none';
        
        showNotification('Ø§Ø² Ú†Øª Ø®Ø§Ø±Ø¬ Ø´Ø¯ÛŒØ¯', 'info');
    }
}

// ==================== Ø´Ø±ÙˆØ¹ Ø³ÛŒØ³ØªÙ… ====================
document.addEventListener('DOMContentLoaded', initSystem);
